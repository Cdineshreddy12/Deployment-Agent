const mongoose = require('mongoose');

const statusHistorySchema = new mongoose.Schema({
  status: {
    type: String,
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  reason: {
    type: String
  }
});

const resourceSchema = new mongoose.Schema({
  type: {
    type: String,
    required: true
  },
  name: {
    type: String,
    required: true
  },
  identifier: {
    type: String,
    required: true
  },
  status: {
    type: String
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

const approvalSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  userName: {
    type: String,
    required: true
  },
  decision: {
    type: String,
    enum: ['approved', 'rejected'],
    required: true
  },
  comment: {
    type: String
  },
  timestamp: {
    type: Date,
    default: Date.now
  }
});

const previousVersionSchema = new mongoose.Schema({
  version: {
    type: Number,
    required: true
  },
  stateKey: {
    type: String,
    required: true
  },
  deployedAt: {
    type: Date,
    required: true
  }
});

const deploymentSchema = new mongoose.Schema({
  deploymentId: {
    type: String,
    required: true, // Required, but generated by pre-validate hook
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  userName: {
    type: String,
    required: true
  },
  userEmail: {
    type: String,
    required: true
  },
  team: {
    type: String
  },
  name: {
    type: String,
    required: true
  },
  description: {
    type: String
  },
  environment: {
    type: String,
    enum: ['development', 'staging', 'production'],
    required: true
  },
  region: {
    type: String,
    default: 'us-east-1'
  },
  status: {
    type: String,
    enum: [
      'INITIATED',
      'GITHUB_INPUT',
      'ANALYZING',
      'REPOSITORY_ANALYSIS',
      'CODE_ANALYSIS',
      'INFRASTRUCTURE_DISCOVERY',
      'DEPENDENCY_ANALYSIS',
      'GATHERING',
      'PLANNING',
      'ENV_COLLECTION',
      'CREDENTIAL_COLLECTION',
      'VALIDATING',
      'VALIDATION_FAILED',
      'ESTIMATED',
      'PENDING_APPROVAL',
      'SANDBOX_DEPLOYING',
      'SANDBOX_TESTING',
      'SANDBOX_FAILED',
      'TESTING',
      'SANDBOX_VALIDATED',
      'APPROVED',
      'REJECTED',
      'GITHUB_COMMIT',
      'GITHUB_ACTIONS',
      'DEPLOYING',
      'DEPLOYMENT_FAILED',
      'DEPLOYED',
      'ROLLING_BACK',
      'ROLLED_BACK',
      'ROLLBACK_FAILED',
      'CANCELLED',
      'DESTROYING',
      'DESTROYED'
    ],
    default: 'INITIATED'
  },
  previousStatus: {
    type: String
  },
  statusHistory: [statusHistorySchema],
  conversationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Conversation'
  },
  requirements: {
    original: {
      type: String
    },
    structured: {
      type: mongoose.Schema.Types.Mixed
    }
  },
  terraformVersion: {
    type: String,
    default: '1.6.0'
  },
  terraformCode: {
    main: {
      type: String
    },
    variables: {
      type: String
    },
    outputs: {
      type: String
    },
    providers: {
      type: String
    },
    modules: {
      type: mongoose.Schema.Types.Mixed
    }
  },
  terraformPlan: {
    type: String
  },
  terraformStateKey: {
    type: String
  },
  resources: [resourceSchema],
  resourceCount: {
    type: Number,
    default: 0
  },
  sandboxId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Sandbox'
  },
  sandboxTestResults: {
    passed: {
      type: Boolean
    },
    tests: [{
      name: String,
      passed: Boolean,
      duration: Number,
      details: mongoose.Schema.Types.Mixed
    }],
    completedAt: {
      type: Date
    }
  },
  approvalRequired: {
    type: Boolean,
    default: false
  },
  approvalStatus: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'pending'
  },
  approvals: [approvalSchema],
  requiredApprovals: {
    type: Number,
    default: 0
  },
  estimatedMonthlyCost: {
    type: Number
  },
  actualMonthlyCost: {
    type: Number
  },
  costBreakdown: {
    compute: Number,
    database: Number,
    networking: Number,
    storage: Number,
    other: Number
  },
  budget: {
    monthly: {
      type: Number
    },
    alertThreshold: {
      type: Number,
      default: 0.8
    }
  },
  version: {
    type: Number,
    default: 1
  },
  deployedAt: {
    type: Date
  },
  canRollback: {
    type: Boolean,
    default: true
  },
  previousVersions: [previousVersionSchema],
  // Step completion tracking
  stepStatus: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  tags: {
    Environment: String,
    Project: String,
    Owner: String,
    CostCenter: String,
    ManagedBy: {
      type: String,
      default: 'deployment-platform'
    }
  },
  // GitHub Integration Fields
  repositoryUrl: {
    type: String
  },
  repositoryBranch: {
    type: String,
    default: 'main'
  },
  githubToken: {
    type: String // Encrypted GitHub PAT token
  },
  codeAnalysis: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CodeAnalysis'
  },
  existingInfrastructure: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'InfrastructureDiscovery'
  },
  githubCommitSha: {
    type: String
  },
  githubActionsRunId: {
    type: String
  },
  githubPullRequestUrl: {
    type: String
  },
  // Wizard Session Reference
  wizardSessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'WizardSession'
  },
  wizardStatus: {
    type: String,
    enum: ['not_started', 'active', 'paused', 'completed', 'failed'],
    default: 'not_started'
  },
  // Workspace path for Cursor integration (persisted)
  workspacePath: {
    type: String
  }
}, {
  timestamps: true
});

// Indexes
// Note: deploymentId index is created automatically by unique: true in schema
deploymentSchema.index({ userId: 1, status: 1 });
deploymentSchema.index({ environment: 1, status: 1 });
deploymentSchema.index({ createdAt: -1 });
deploymentSchema.index({ 'tags.Environment': 1, 'tags.Project': 1 });

// Generate deploymentId before validation (runs before validation)
deploymentSchema.pre('validate', function(next) {
  // Always generate deploymentId if it doesn't exist (for new documents)
  if (!this.deploymentId && this.isNew) {
    const { v4: uuidv4 } = require('uuid');
    const shortId = uuidv4().split('-')[0];
    this.deploymentId = `deploy-${shortId}`;
  }
  next();
});

// Additional setup before saving
deploymentSchema.pre('save', async function(next) {
  try {
    // Initialize status history
    if (this.isNew && this.statusHistory.length === 0) {
      this.statusHistory.push({
        status: this.status,
        timestamp: new Date()
      });
    }
    
    // Set resource count
    if (this.resources) {
      this.resourceCount = this.resources.length;
    }
    
    next();
  } catch (error) {
    next(error);
  }
});

module.exports = mongoose.model('Deployment', deploymentSchema);

