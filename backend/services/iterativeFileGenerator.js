const claudeService = require('./claude');
const fileCheckService = require('./fileCheckService');
const cursorIntegration = require('./cursorIntegration');
const logger = require('../utils/logger');
const stepCompletionGate = require('./stepCompletionGate');

/**
 * Iterative File Generator Service
 * README-based iterative file generation workflow
 */
class IterativeFileGenerator {
  /**
   * Generate file requirements README
   */
  async generateFileRequirements(deploymentId, projectType = null) {
    try {
      const Deployment = require('../models/Deployment');
      const deployment = await Deployment.findOne({ deploymentId });
      
      if (!deployment) {
        throw new Error('Deployment not found');
      }

      // Determine required files based on project type
      const requiredFiles = this.getRequiredFiles(projectType);
      
      // Generate README with file requirements
      const readmeContent = this.buildRequirementsREADME(requiredFiles, projectType);

      // Write README to workspace
      const workspacePath = cursorIntegration.getWorkspacePath(deploymentId);
      if (workspacePath) {
        const fs = require('fs-extra');
        const path = require('path');
        const readmePath = path.join(workspacePath, 'DEPLOYMENT_FILES_REQUIRED.md');
        await fs.writeFile(readmePath, readmeContent);
      }

      // Store file requirements in deployment
      await Deployment.findOneAndUpdate(
        { deploymentId },
        {
          $set: {
            'requirements.fileRequirements': {
              requiredFiles,
              readmeGenerated: true,
              readmePath: workspacePath ? 'DEPLOYMENT_FILES_REQUIRED.md' : null
            }
          }
        }
      );

      logger.info('File requirements README generated', {
        deploymentId,
        requiredFiles: requiredFiles.length
      });

      return {
        success: true,
        readmeContent,
        requiredFiles
      };
    } catch (error) {
      logger.error('Failed to generate file requirements:', error);
      throw error;
    }
  }

  /**
   * Get required files based on project type
   */
  getRequiredFiles(projectType) {
    const baseFiles = ['Dockerfile', 'docker-compose.yml'];
    
    const typeSpecificFiles = {
      'nodejs': ['package.json', '.dockerignore'],
      'python': ['requirements.txt', '.dockerignore'],
      'go': ['go.mod', '.dockerignore'],
      'java': ['pom.xml', '.dockerignore'],
      'ruby': ['Gemfile', '.dockerignore']
    };

    const files = [...baseFiles];
    if (projectType && typeSpecificFiles[projectType.toLowerCase()]) {
      files.push(...typeSpecificFiles[projectType.toLowerCase()]);
    }

    return files;
  }

  /**
   * Build requirements README content
   */
  buildRequirementsREADME(requiredFiles, projectType) {
    return `# Deployment Files Required

This document lists the files required for deployment. Please generate these files using Cursor AI.

## Required Files

${requiredFiles.map((file, index) => `${index + 1}. **${file}**`).join('\n')}

## Instructions

1. Use Cursor AI to generate each file based on your project requirements
2. The agent will verify each file after generation
3. Once all files are verified, deployment will proceed

## File Details

${requiredFiles.map(file => this.getFileDescription(file)).join('\n\n')}

## Verification

After generating files, the deployment agent will:
- Check file existence
- Verify file content
- Validate file structure
- Proceed to next step once all files are complete

---
Generated by Deployment Agent
`;
  }

  /**
   * Get file description for README
   */
  getFileDescription(filename) {
    const descriptions = {
      'Dockerfile': 'Dockerfile for containerizing the application. Should include multi-stage builds and security best practices.',
      'docker-compose.yml': 'Docker Compose configuration for local development and testing.',
      '.dockerignore': 'Files and directories to exclude from Docker build context.',
      'package.json': 'Node.js dependencies and scripts (if applicable).',
      'requirements.txt': 'Python dependencies (if applicable).',
      'go.mod': 'Go module dependencies (if applicable).',
      'pom.xml': 'Maven project configuration (if applicable).',
      'Gemfile': 'Ruby dependencies (if applicable).'
    };

    return `### ${filename}\n${descriptions[filename] || 'Required file for deployment.'}`;
  }

  /**
   * Check file generation status
   */
  async checkFileGenerationStatus(deploymentId) {
    try {
      const Deployment = require('../models/Deployment');
      const deployment = await Deployment.findOne({ deploymentId });
      
      if (!deployment) {
        throw new Error('Deployment not found');
      }

      const fileRequirements = deployment.requirements?.fileRequirements;
      if (!fileRequirements || !fileRequirements.requiredFiles) {
        return {
          status: 'no_requirements',
          files: []
        };
      }

      const requiredFiles = fileRequirements.requiredFiles;
      const fileStatuses = await fileCheckService.batchCheckFiles(deploymentId, requiredFiles);

      const existing = [];
      const missing = [];

      for (const [file, status] of Object.entries(fileStatuses)) {
        if (status.exists) {
          existing.push(file);
        } else {
          missing.push(file);
        }
      }

      return {
        status: missing.length === 0 ? 'complete' : 'in_progress',
        totalFiles: requiredFiles.length,
        existingFiles: existing,
        missingFiles: missing,
        fileStatuses
      };
    } catch (error) {
      logger.error('Failed to check file generation status:', error);
      return {
        status: 'error',
        error: error.message,
        files: []
      };
    }
  }

  /**
   * Verify file content using terminal commands
   */
  async verifyFileContent(deploymentId, filePath) {
    try {
      const cliExecutor = require('./cliExecutor');
      const workspacePath = cursorIntegration.getWorkspacePath(deploymentId);
      
      // Check if file exists first
      const fileInfo = await fileCheckService.getFileInfo(deploymentId, filePath);
      if (!fileInfo.exists) {
        return {
          valid: false,
          reason: 'File does not exist'
        };
      }

      // Read file content using terminal (cat or head)
      const command = `head -n 50 "${fileInfo.path}"`;
      const result = await cliExecutor.executeDeployment(deploymentId, command, {
        cwd: workspacePath
      });

      const content = result?.stdout || result?.output || '';
      
      // Basic validation based on file type
      const validation = this.validateFileContent(filePath, content);

      return {
        valid: validation.valid,
        reason: validation.reason,
        preview: content.substring(0, 500),
        size: fileInfo.size
      };
    } catch (error) {
      logger.error('Failed to verify file content:', error);
      return {
        valid: false,
        reason: `Verification error: ${error.message}`
      };
    }
  }

  /**
   * Validate file content based on file type
   */
  validateFileContent(filePath, content) {
    const filename = filePath.toLowerCase();
    
    if (filename.includes('dockerfile')) {
      if (!content.includes('FROM')) {
        return {
          valid: false,
          reason: 'Dockerfile missing FROM instruction'
        };
      }
      return { valid: true, reason: 'Dockerfile structure valid' };
    }

    if (filename.includes('docker-compose')) {
      if (!content.includes('version') && !content.includes('services')) {
        return {
          valid: false,
          reason: 'docker-compose.yml missing version or services'
        };
      }
      return { valid: true, reason: 'docker-compose.yml structure valid' };
    }

    if (filename.includes('package.json')) {
      try {
        JSON.parse(content);
        return { valid: true, reason: 'package.json is valid JSON' };
      } catch (e) {
        return {
          valid: false,
          reason: 'package.json is not valid JSON'
        };
      }
    }

    // Default: file exists and has content
    if (content.trim().length === 0) {
      return {
        valid: false,
        reason: 'File is empty'
      };
    }

    return { valid: true, reason: 'File content valid' };
  }

  /**
   * Wait for file generation with polling
   */
  async waitForFileGeneration(deploymentId, filePath, timeout = 300000, interval = 5000) {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const fileInfo = await fileCheckService.getFileInfo(deploymentId, filePath);
      
      if (fileInfo.exists) {
        // Verify content
        const verification = await this.verifyFileContent(deploymentId, filePath);
        if (verification.valid) {
          return {
            success: true,
            filePath,
            verified: true
          };
        }
      }

      // Wait before next check
      await new Promise(resolve => setTimeout(resolve, interval));
    }

    return {
      success: false,
      filePath,
      reason: 'Timeout waiting for file generation'
    };
  }

  /**
   * Continue file generation workflow
   */
  async continueFileGeneration(deploymentId) {
    try {
      const status = await this.checkFileGenerationStatus(deploymentId);
      
      if (status.status === 'complete') {
        // Mark FILE_GENERATION step as complete
        await stepCompletionGate.markStepComplete(deploymentId, 'FILE_GENERATION', {
          filesGenerated: status.existingFiles
        });

        return {
          complete: true,
          message: 'All required files generated',
          files: status.existingFiles
        };
      }

      // Check which files are missing and verify existing ones
      const verificationResults = {};
      
      for (const file of status.existingFiles || []) {
        verificationResults[file] = await this.verifyFileContent(deploymentId, file);
      }

      const invalidFiles = Object.entries(verificationResults)
        .filter(([_, result]) => !result.valid)
        .map(([file, _]) => file);

      return {
        complete: false,
        status: 'in_progress',
        existingFiles: status.existingFiles,
        missingFiles: status.missingFiles,
        invalidFiles,
        message: invalidFiles.length > 0
          ? `Files need correction: ${invalidFiles.join(', ')}`
          : `Waiting for files: ${status.missingFiles.join(', ')}`
      };
    } catch (error) {
      logger.error('Failed to continue file generation:', error);
      return {
        complete: false,
        error: error.message
      };
    }
  }
}

// Singleton instance
const iterativeFileGenerator = new IterativeFileGenerator();

module.exports = iterativeFileGenerator;

