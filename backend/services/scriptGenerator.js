const cursorIntegration = require('./cursorIntegration');
const requirementParser = require('./requirementParser');
const infrastructureGenerator = require('./infrastructureGenerator');
const logger = require('../utils/logger');
const path = require('path');

/**
 * Script Generator Service
 * Generates deployment scripts directly in user's codebase via Cursor integration
 * Enhanced with validation to prevent overwriting existing files
 */
class ScriptGenerator {
  /**
   * Validate project before generating scripts
   */
  async validateProject(deploymentId, requirements) {
    const validation = {
      valid: true,
      errors: [],
      warnings: [],
      existingFiles: [],
      missingScripts: [],
      recommendations: []
    };

    // Check which npm scripts exist
    if (requirements.configFiles?.packageJson?.analysis) {
      const pkgAnalysis = requirements.configFiles.packageJson.analysis;
      
      if (!pkgAnalysis.scriptValidation?.hasBuildScript) {
        validation.warnings.push('No "build" script in package.json');
        validation.missingScripts.push('build');
        validation.recommendations.push('Add a "build" script to package.json or skip build step during deployment');
      }
      
      if (!pkgAnalysis.scriptValidation?.hasStartScript) {
        validation.warnings.push('No "start" script in package.json');
        validation.missingScripts.push('start');
        validation.recommendations.push('Add a "start" script to package.json to define how to run the application');
      }
    }

    // Check for existing files that would be overwritten
    const filesToCheck = [
      'Dockerfile',
      'docker-compose.yml',
      'deploy.sh',
      'build.sh',
      '.github/workflows/deploy.yml'
    ];

    for (const file of filesToCheck) {
      const exists = await cursorIntegration.fileExists(deploymentId, file);
      if (exists) {
        validation.existingFiles.push(file);
        validation.warnings.push(`${file} already exists and will NOT be overwritten`);
      }
    }

    // Check for lock file to determine package manager
    const lockFiles = [
      { file: 'package-lock.json', manager: 'npm' },
      { file: 'yarn.lock', manager: 'yarn' },
      { file: 'pnpm-lock.yaml', manager: 'pnpm' }
    ];

    validation.packageManager = 'npm'; // Default
    for (const { file, manager } of lockFiles) {
      const exists = await cursorIntegration.fileExists(deploymentId, file);
      if (exists) {
        validation.packageManager = manager;
        break;
      }
    }

    return validation;
  }

  /**
   * Generate deploy.sh script with conditional steps
   */
  async generateDeployScript(deploymentId, requirements, projectType, validation = null) {
    validation = validation || await this.validateProject(deploymentId, requirements);
    
    const hasBuild = !validation.missingScripts?.includes('build');
    const hasTest = requirements.configFiles?.packageJson?.analysis?.scriptValidation?.hasTestScript;
    const pm = validation.packageManager || 'npm';

    let buildStep = '';
    if (hasBuild) {
      buildStep = this.getBuildCommand(requirements, projectType, pm);
    } else {
      buildStep = `echo "â„¹ï¸  No build script found in package.json - skipping build step"`;
    }

    let testStep = '';
    if (hasTest) {
      testStep = `${pm === 'npm' ? 'npm test' : `${pm} test`} || echo "âš ï¸ Tests failed or skipped"`;
    } else {
      testStep = `echo "â„¹ï¸  No test script found in package.json - skipping tests"`;
    }

    const script = `#!/bin/bash
# Deployment Script
# Generated by Deployment Agent
# Project: ${requirements.configFiles?.packageJson?.analysis?.name || 'Unknown'}
# Generated: ${new Date().toISOString()}

set -e  # Exit on error

echo "ðŸš€ Starting deployment..."

# Load environment variables
if [ -f .env ]; then
  echo "ðŸ“‹ Loading environment variables from .env"
  export $(cat .env | grep -v '^#' | xargs)
fi

# Install dependencies
echo "ðŸ“¦ Installing dependencies..."
${this.getInstallCommand(pm)}

# Build step
echo "ðŸ”¨ Building application..."
${buildStep}

# Run tests
echo "ðŸ§ª Running tests..."
${testStep}

# Deploy step
${this.getDeployCommand(requirements, projectType)}

echo "âœ… Deployment completed successfully!"
`;

    return script;
  }

  /**
   * Generate build.sh script with validation
   */
  async generateBuildScript(deploymentId, requirements, projectType, validation = null) {
    validation = validation || await this.validateProject(deploymentId, requirements);
    
    const hasBuild = !validation.missingScripts?.includes('build');
    const pm = validation.packageManager || 'npm';

    let buildCommand = '';
    if (hasBuild) {
      buildCommand = this.getBuildCommand(requirements, projectType, pm);
    } else {
      buildCommand = `echo "âš ï¸ Warning: No build script found in package.json"
echo "Add a 'build' script to package.json or modify this script manually"
exit 0  # Exit successfully since build is optional`;
    }

    const script = `#!/bin/bash
# Build Script
# Generated by Deployment Agent
# Project: ${requirements.configFiles?.packageJson?.analysis?.name || 'Unknown'}
# Generated: ${new Date().toISOString()}

set -e

echo "ðŸ”¨ Building application..."

# Install dependencies first
${this.getInstallCommand(pm)}

# Build
${buildCommand}

echo "âœ… Build completed!"
`;

    return script;
  }

  /**
   * Get install command based on package manager
   */
  getInstallCommand(packageManager) {
    switch (packageManager) {
      case 'yarn':
        return 'yarn install';
      case 'pnpm':
        return 'pnpm install';
      default:
        return 'npm install';
    }
  }

  /**
   * Get build command based on project type with package manager support
   */
  getBuildCommand(requirements, projectType, packageManager = 'npm') {
    // Check if package.json has a build script
    const hasBuildScript = requirements.configFiles?.packageJson?.analysis?.scriptValidation?.hasBuildScript;
    
    if (!hasBuildScript) {
      return 'echo "No build script in package.json - skipping build"';
    }

    if (requirements.buildCommands && requirements.buildCommands.length > 0) {
      return requirements.buildCommands[0];
    }

    const type = projectType.type || 'nodejs';
    
    switch (type) {
      case 'nodejs':
        switch (packageManager) {
          case 'yarn': return 'yarn build';
          case 'pnpm': return 'pnpm build';
          default: return 'npm run build';
        }
      case 'python':
        return 'pip install -r requirements.txt';
      case 'go':
        return 'go build -o app';
      case 'java':
        return 'mvn clean package';
      case 'rust':
        return 'cargo build --release';
      default:
        return 'echo "No build command configured"';
    }
  }

  /**
   * Get test command with validation
   */
  getTestCommand(requirements, projectType) {
    const hasTestScript = requirements.configFiles?.packageJson?.analysis?.scriptValidation?.hasTestScript;
    
    if (!hasTestScript) {
      return 'echo "No test script in package.json - skipping tests"';
    }

    const type = projectType.type || 'nodejs';
    
    switch (type) {
      case 'nodejs':
        return 'npm test || echo "Tests skipped"';
      case 'python':
        return 'pytest || echo "Tests skipped"';
      case 'go':
        return 'go test ./... || echo "Tests skipped"';
      default:
        return 'echo "No test command configured"';
    }
  }

  /**
   * Get deploy command
   */
  getDeployCommand(requirements, projectType) {
    // This will be customized based on infrastructure type
    if (requirements.infrastructureNeeds && requirements.infrastructureNeeds.includes('docker')) {
      return 'docker-compose up -d';
    }
    
    return 'echo "Deploy command will be configured based on infrastructure"';
  }

  /**
   * Generate Dockerfile if missing
   */
  async generateDockerfile(deploymentId, requirements, projectType) {
    try {
      // Check if Dockerfile already exists
      const exists = await cursorIntegration.fileExists(deploymentId, 'Dockerfile');
      if (exists) {
        logger.info('Dockerfile already exists, skipping generation');
        return null;
      }

      const type = projectType.type || 'nodejs';
      const framework = projectType.framework || 'vanilla';

      let dockerfile = '';

      switch (type) {
        case 'nodejs':
          dockerfile = this.generateNodejsDockerfile(framework, requirements);
          break;
        case 'python':
          dockerfile = this.generatePythonDockerfile(requirements);
          break;
        case 'go':
          dockerfile = this.generateGoDockerfile(requirements);
          break;
        default:
          dockerfile = this.generateGenericDockerfile(type, requirements);
      }

      // Write to workspace
      await cursorIntegration.writeFile(deploymentId, 'Dockerfile', dockerfile);

      return {
        success: true,
        filePath: 'Dockerfile',
        content: dockerfile
      };
    } catch (error) {
      logger.error(`Failed to generate Dockerfile for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Generate Node.js Dockerfile
   */
  generateNodejsDockerfile(framework, requirements) {
    return `# Multi-stage build for Node.js application
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build || echo "No build script"

# Production stage
FROM node:18-alpine

WORKDIR /app

# Copy built application and dependencies
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nodejs -u 1001

USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" || exit 1

# Start application
CMD ["npm", "start"]
`;
  }

  /**
   * Generate Python Dockerfile
   */
  generatePythonDockerfile(requirements) {
    return `# Multi-stage build for Python application
FROM python:3.11-slim AS builder

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Copy dependencies
COPY --from=builder /root/.local /root/.local
COPY . .

# Make sure scripts in .local are usable
ENV PATH=/root/.local/bin:$PATH

# Create non-root user
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1

# Start application
CMD ["python", "app.py"]
`;
  }

  /**
   * Generate Go Dockerfile
   */
  generateGoDockerfile(requirements) {
    return `# Multi-stage build for Go application
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

# Production stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Copy binary from builder
COPY --from=builder /app/app .

# Create non-root user
RUN addgroup -g 1001 appgroup && \\
    adduser -D -u 1001 -G appgroup appuser && \\
    chown appuser:appgroup app

USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Start application
CMD ["./app"]
`;
  }

  /**
   * Generate generic Dockerfile
   */
  generateGenericDockerfile(type, requirements) {
    return `# Dockerfile for ${type} application
# Generated by Deployment Agent

FROM ${type}:latest

WORKDIR /app

COPY . .

# Add your build and run commands here
# CMD ["your", "command"]
`;
  }

  /**
   * Generate docker-compose.yml
   */
  async generateDockerCompose(deploymentId, requirements, projectType) {
    try {
      const exists = await cursorIntegration.fileExists(deploymentId, 'docker-compose.yml');
      if (exists) {
        logger.info('docker-compose.yml already exists, skipping generation');
        return null;
      }

      const compose = `version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    volumes:
      - .:/app
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

networks:
  default:
    name: app-network
`;

      await cursorIntegration.writeFile(deploymentId, 'docker-compose.yml', compose);

      return {
        success: true,
        filePath: 'docker-compose.yml',
        content: compose
      };
    } catch (error) {
      logger.error(`Failed to generate docker-compose.yml for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Generate GitHub Actions workflow
   */
  async generateGitHubActions(deploymentId, requirements, projectType) {
    try {
      const workflowDir = '.github/workflows';
      const workflowFile = `${workflowDir}/deploy.yml`;
      
      const exists = await cursorIntegration.fileExists(deploymentId, workflowFile);
      if (exists) {
        logger.info('GitHub Actions workflow already exists, skipping generation');
        return null;
      }

      const workflow = `name: Deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Deploy
        run: |
          echo "Add your deployment steps here"
          # Add AWS CLI, Docker, or other deployment commands
`;

      await cursorIntegration.writeFile(deploymentId, workflowFile, workflow);

      return {
        success: true,
        filePath: workflowFile,
        content: workflow
      };
    } catch (error) {
      logger.error(`Failed to generate GitHub Actions workflow for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Generate all deployment scripts with validation
   */
  async generateAllScripts(deploymentId, requirements, projectType, options = {}) {
    const generated = [];
    const skipped = [];

    try {
      // Run validation first
      const validation = await this.validateProject(deploymentId, requirements);
      
      logger.info(`Validation results for ${deploymentId}:`, {
        existingFiles: validation.existingFiles,
        missingScripts: validation.missingScripts,
        warnings: validation.warnings
      });

      // Generate deploy.sh only if it doesn't exist or force is true
      if (!validation.existingFiles.includes('deploy.sh') || options.overwrite) {
        const deployScript = await this.generateDeployScript(deploymentId, requirements, projectType, validation);
        await cursorIntegration.writeFile(deploymentId, 'deploy.sh', deployScript);
        await this.makeExecutable(deploymentId, 'deploy.sh');
        generated.push({ file: 'deploy.sh', type: 'script' });
      } else {
        skipped.push({ file: 'deploy.sh', reason: 'File already exists' });
      }

      // Generate build.sh only if it doesn't exist or force is true
      if (!validation.existingFiles.includes('build.sh') || options.overwrite) {
        const buildScript = await this.generateBuildScript(deploymentId, requirements, projectType, validation);
        await cursorIntegration.writeFile(deploymentId, 'build.sh', buildScript);
        await this.makeExecutable(deploymentId, 'build.sh');
        generated.push({ file: 'build.sh', type: 'script' });
      } else {
        skipped.push({ file: 'build.sh', reason: 'File already exists' });
      }

      // Generate Dockerfile if missing (already checks internally)
      const dockerfile = await this.generateDockerfile(deploymentId, requirements, projectType);
      if (dockerfile) {
        generated.push({ file: 'Dockerfile', type: 'dockerfile' });
      } else if (validation.existingFiles.includes('Dockerfile')) {
        skipped.push({ file: 'Dockerfile', reason: 'File already exists' });
      }

      // Generate docker-compose.yml if needed (already checks internally)
      if (requirements.infrastructureNeeds && requirements.infrastructureNeeds.includes('docker')) {
        const compose = await this.generateDockerCompose(deploymentId, requirements, projectType);
        if (compose) {
          generated.push({ file: 'docker-compose.yml', type: 'compose' });
        } else if (validation.existingFiles.includes('docker-compose.yml')) {
          skipped.push({ file: 'docker-compose.yml', reason: 'File already exists' });
        }
      }

      logger.info(`Script generation complete for ${deploymentId}: ${generated.length} generated, ${skipped.length} skipped`);

      return {
        success: true,
        generated,
        skipped,
        validation: {
          packageManager: validation.packageManager,
          warnings: validation.warnings,
          missingScripts: validation.missingScripts,
          recommendations: validation.recommendations
        }
      };
    } catch (error) {
      logger.error(`Failed to generate scripts for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Make script executable (chmod +x)
   */
  async makeExecutable(deploymentId, filePath) {
    try {
      const workspacePath = cursorIntegration.getWorkspacePath(deploymentId);
      if (!workspacePath) {
        return;
      }

      const fullPath = path.resolve(workspacePath, filePath);
      const fs = require('fs-extra');
      await fs.chmod(fullPath, 0o755);
    } catch (error) {
      logger.warn(`Failed to make ${filePath} executable:`, error);
      // Non-critical, continue
    }
  }
}

module.exports = new ScriptGenerator();


