const cursorIntegration = require('./cursorIntegration');
const deploymentEnvService = require('./deploymentEnvService');
const credentialManager = require('./credentialManager');
const requirementParser = require('./requirementParser');
const logger = require('../utils/logger');

/**
 * Environment Variable Manager
 * Handles .env files from Cursor workspace and stores credentials securely
 */
class EnvManager {
  /**
   * Parse .env file from workspace
   */
  async parseEnvFile(deploymentId, filePath = '.env') {
    try {
      const fileData = await cursorIntegration.readFile(deploymentId, filePath);
      
      if (!fileData || !fileData.exists) {
        return {
          variables: [],
          fileExists: false
        };
      }

      const variables = requirementParser.parseEnvFile(fileData.content);
      
      return {
        variables,
        fileExists: true,
        filePath
      };
    } catch (error) {
      logger.error(`Failed to parse .env file for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Get environment variables from .env.example or .env
   */
  async getEnvVariables(deploymentId) {
    try {
      // Try .env.example first (preferred for templates)
      let envData = await this.parseEnvFile(deploymentId, '.env.example');
      
      // Fallback to .env if .env.example doesn't exist
      if (!envData.fileExists) {
        envData = await this.parseEnvFile(deploymentId, '.env');
      }

      return envData.variables;
    } catch (error) {
      logger.error(`Failed to get environment variables for deployment ${deploymentId}:`, error);
      return [];
    }
  }

  /**
   * Store environment variables securely per deployment
   */
  async storeEnvVariables(deploymentId, userId, variables) {
    try {
      // Get or create deployment environment
      const deploymentEnv = await deploymentEnvService.getOrCreate(deploymentId, userId);

      // Convert array of {name, value} to Map
      const envMap = new Map();
      for (const variable of variables) {
        if (variable.name && variable.value !== undefined) {
          envMap.set(variable.name, variable.value);
        }
      }

      // Update deployment environment
      deploymentEnv.envVariables = envMap;
      await deploymentEnv.save();

      logger.info(`Stored ${envMap.size} environment variables for deployment ${deploymentId}`);

      return {
        success: true,
        count: envMap.size
      };
    } catch (error) {
      logger.error(`Failed to store environment variables for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Get stored environment variables for deployment
   */
  async getStoredEnvVariables(deploymentId, userId) {
    try {
      const deploymentEnv = await deploymentEnvService.getOrCreate(deploymentId, userId);
      
      const variables = [];
      if (deploymentEnv.envVariables instanceof Map) {
        for (const [name, value] of deploymentEnv.envVariables.entries()) {
          variables.push({ name, value });
        }
      }

      return variables;
    } catch (error) {
      logger.error(`Failed to get stored environment variables for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Generate .env template from detected variables
   */
  async generateEnvTemplate(deploymentId) {
    try {
      const variables = await this.getEnvVariables(deploymentId);
      
      let template = '# Environment Variables\n';
      template += '# Generated by Deployment Agent\n\n';

      for (const variable of variables) {
        template += `${variable.name}=${variable.defaultValue || ''}\n`;
      }

      return template;
    } catch (error) {
      logger.error(`Failed to generate .env template for deployment ${deploymentId}:`, error);
      throw error;
    }
  }

  /**
   * Validate required environment variables
   */
  validateEnvVariables(requiredVariables, providedVariables) {
    const providedNames = new Set(providedVariables.map(v => v.name));
    const missing = [];
    const invalid = [];

    for (const required of requiredVariables) {
      if (required.required && !providedNames.has(required.name)) {
        missing.push(required.name);
      }
    }

    return {
      valid: missing.length === 0,
      missing,
      invalid
    };
  }

  /**
   * Export environment variables as .env format string
   */
  exportAsEnvFormat(variables) {
    let envContent = '# Environment Variables\n';
    envContent += '# Exported from Deployment Agent\n\n';

    for (const variable of variables) {
      envContent += `${variable.name}=${variable.value || ''}\n`;
    }

    return envContent;
  }

  /**
   * Import environment variables from .env format string
   */
  importFromEnvFormat(envContent) {
    const variables = [];
    const lines = envContent.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)\s*=\s*(.*)$/);
        if (match) {
          variables.push({
            name: match[1],
            value: match[2]
          });
        }
      }
    }

    return variables;
  }

  /**
   * Merge environment variables from multiple sources
   */
  mergeEnvVariables(...sources) {
    const merged = new Map();

    for (const source of sources) {
      for (const variable of source) {
        if (variable.name) {
          merged.set(variable.name, variable);
        }
      }
    }

    return Array.from(merged.values());
  }
}

module.exports = new EnvManager();





